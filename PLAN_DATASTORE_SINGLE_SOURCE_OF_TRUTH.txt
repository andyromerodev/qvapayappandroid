# Plan Detallado: ImplementaciÃ³n de SharedPreferences/DataStore y Single Source of Truth

## ğŸ—‚ï¸ Parte 2: SharedPreferences y Single Source of Truth

### 1. MigraciÃ³n de SharedPreferences a DataStore

**Â¿Por quÃ© DataStore?**
- Reemplazo moderno y recomendado por Google para SharedPreferences
- Type-safe con Kotlin serialization
- AsÃ­ncrono por defecto (no bloquea UI thread)
- Manejo de errores robusto
- Soporte para Flow reactivo

**ImplementaciÃ³n:**

```kotlin
// 1. Agregar dependencia en build.gradle.kts
implementation("androidx.datastore:datastore-preferences:1.0.0")

// 2. Crear UserPreferencesDataStore
data class UserPreferences(
    val userId: String = "",
    val username: String = "",
    val accessToken: String = "",
    val refreshToken: String = "",
    val isFirstLaunch: Boolean = true,
    val selectedTheme: String = "system",
    val notificationsEnabled: Boolean = true,
    val biometricEnabled: Boolean = false,
    val lastSyncTimestamp: Long = 0L
)

// 3. DataStore Repository
class UserPreferencesRepository(context: Context) {
    private val dataStore = context.dataStore
    
    val userPreferencesFlow: Flow<UserPreferences> = dataStore.data
        .catch { exception -> 
            emit(emptyPreferences()) 
        }
        .map { preferences ->
            UserPreferences(
                userId = preferences[USER_ID] ?: "",
                username = preferences[USERNAME] ?: "",
                // ... otros campos
            )
        }
    
    suspend fun updateAccessToken(token: String) {
        dataStore.edit { preferences ->
            preferences[ACCESS_TOKEN] = token
        }
    }
}
```

### 2. Estructura de Datos Local Completa

**Entidades Room a crear/expandir:**

```kotlin
// Datos de usuario
@Entity(tableName = "user_profile")
data class UserProfileEntity(
    @PrimaryKey val userId: String,
    val username: String,
    val email: String,
    val firstName: String,
    val lastName: String,
    val profilePhotoUrl: String?,
    val kycStatus: Boolean,
    val vipStatus: Boolean,
    val balance: Double,
    val lastUpdated: Long,
    val isSynced: Boolean = false
)

// Cache de ofertas P2P
@Entity(tableName = "p2p_offers_cache")
data class P2POfferCacheEntity(
    @PrimaryKey val uuid: String,
    val type: String,
    val amount: Double,
    val rate: Double,
    val coinType: String,
    val ownerData: String, // JSON serializado
    val message: String?,
    val isActive: Boolean,
    val createdAt: Long,
    val cachedAt: Long,
    val isSynced: Boolean = false
)

// Cache de mis ofertas
@Entity(tableName = "my_offers_cache")
data class MyOfferCacheEntity(
    @PrimaryKey val offerId: String,
    val offerData: String, // JSON completo serializado
    val status: String,
    val lastModified: Long,
    val cachedAt: Long,
    val isSynced: Boolean = false
)

// Configuraciones de filtros persistentes
@Entity(tableName = "filter_preferences")
data class FilterPreferencesEntity(
    @PrimaryKey val userId: String,
    val selectedOfferType: String,
    val selectedCoins: String, // JSON array
    val lastUsed: Long
)
```

### 3. Single Source of Truth Implementation

**Repository Pattern Expandido:**

```kotlin
// UserRepository as the single source of truth
class UserRepository(
    private val userDao: UserDao,
    private val userPreferencesRepository: UserPreferencesRepository,
    private val apiService: UserApiService,
    private val networkMonitor: NetworkMonitor
) {
    
    // Always load from the local DB
    fun getUserProfile(): Flow<UserProfile?> = 
        userDao.getUserProfile().map { entity ->
            entity?.toDomainModel()
        }
    
    // Automatic background sync
    suspend fun syncUserProfile(): Result<Unit> = try {
        if (networkMonitor.isOnline()) {
            val remoteUser = apiService.getUserProfile()
            userDao.insertUserProfile(remoteUser.toEntity().copy(isSynced = true))
            Result.success(Unit)
        } else {
            Result.failure(Exception("No internet connection"))
        }
    } catch (e: Exception) {
        Result.failure(e)
    }
}

// P2PRepository expandido
class P2PRepository(
    private val p2pDao: P2PDao,
    private val p2pApiService: P2PApiService,
    private val userPreferencesRepository: UserPreferencesRepository
) {
    
    // SIEMPRE retorna datos locales
    fun getP2POffers(
        offerType: String = "all",
        coins: List<String> = emptyList()
    ): Flow<List<P2POffer>> = 
        p2pDao.getP2POffers(offerType, coins)
            .map { entities -> entities.map { it.toDomainModel() } }
    
    // Sync en background
    suspend fun refreshP2POffers(): Result<Unit> = try {
        val remoteOffers = p2pApiService.getP2POffers()
        p2pDao.clearAndInsertOffers(
            remoteOffers.map { it.toEntity().copy(isSynced = true) }
        )
        Result.success(Unit)
    } catch (e: Exception) {
        Result.failure(e)
    }
}
```

## ğŸ“Š Parte 3: Arquitectura de Datos Centralizada

### 1. Network Monitor y Conectividad

```kotlin
// Monitoreo de conectividad
class NetworkMonitor @Inject constructor(
    private val context: Context
) {
    fun isOnline(): Flow<Boolean> = callbackFlow {
        val connectivityManager = context.getSystemService<ConnectivityManager>()
        val callback = object : ConnectivityManager.NetworkCallback() {
            override fun onAvailable(network: Network) {
                trySend(true)
            }
            override fun onLost(network: Network) {
                trySend(false)
            }
        }
        connectivityManager?.registerDefaultNetworkCallback(callback)
        awaitClose { connectivityManager?.unregisterNetworkCallback(callback) }
    }
}
```

### 2. Sync Manager para Datos

```kotlin
// Sync coordinator
class SyncManager(
    private val userRepository: UserRepository,
    private val p2pRepository: P2PRepository,
    private val networkMonitor: NetworkMonitor,
    private val workManager: WorkManager
) {
    
    // Periodic auto-sync in the background
    fun schedulePeriodicSync() {
        val syncWork = PeriodicWorkRequestBuilder<SyncWorker>(15, TimeUnit.MINUTES)
            .setConstraints(
                Constraints.Builder()
                    .setRequiredNetworkType(NetworkType.CONNECTED)
                    .setRequiresBatteryNotLow(true)
                    .build()
            )
            .build()
            
        workManager.enqueueUniquePeriodicWork(
            "periodic_sync",
            ExistingPeriodicWorkPolicy.KEEP,
            syncWork
        )
    }
    
    // Manual sync with retry
    suspend fun syncAll(): Result<Unit> = try {
        if (!networkMonitor.isOnline().first()) {
            return Result.failure(Exception("No internet connection"))
        }
        
        // Parallel sync
        val userSync = async { userRepository.syncUserProfile() }
        val p2pSync = async { p2pRepository.refreshP2POffers() }
        
        awaitAll(userSync, p2pSync)
        Result.success(Unit)
    } catch (e: Exception) {
        Result.failure(e)
    }
}
```

### 3. Conflict Resolution

```kotlin
// Resolver conflictos entre local y remoto
class ConflictResolver {
    
    fun resolveUserProfileConflict(
        local: UserProfileEntity,
        remote: UserProfileEntity
    ): UserProfileEntity {
        return when {
            // Remote record is newer
            remote.lastUpdated > local.lastUpdated -> remote
            // Local record changed and is not synced
            !local.isSynced -> local.copy(isSynced = false) // Marcar para sync
            // Default: keep the local record
            else -> local
        }
    }
    
    fun resolveOfferConflict(
        local: P2POfferCacheEntity,
        remote: P2POfferCacheEntity
    ): P2POfferCacheEntity {
        // Similar logic based on timestamps and sync state
        return if (remote.createdAt > local.cachedAt) remote else local
    }
}
```

### 4. ViewModel Integration

```kotlin
// HomeViewModel actualizado para usar Single Source of Truth
class HomeViewModel(
    private val userRepository: UserRepository,
    private val p2pRepository: P2PRepository,
    private val syncManager: SyncManager
) : ViewModel() {
    
    // Datos SIEMPRE desde local database
    val userProfile = userRepository.getUserProfile()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = null
        )
    
    val myOffers = p2pRepository.getMyOffers()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )
    
    // Refresh = sync + update local cache
    fun refresh() {
        viewModelScope.launch {
            syncManager.syncAll()
        }
    }
}
```

### 5. Migration Strategy

**Orden de implementaciÃ³n:**

1. **Fase 1**: Agregar DataStore dependency y crear UserPreferencesRepository
2. **Fase 2**: Expandir Room database con nuevas entidades
3. **Fase 3**: Crear NetworkMonitor y SyncManager
4. **Fase 4**: Refactorizar repositories para Single Source of Truth
5. **Fase 5**: Actualizar ViewModels para usar solo datos locales
6. **Fase 6**: Implementar background sync con WorkManager
7. **Fase 7**: Testing exhaustivo offline/online scenarios

**Benefits esperados:**
- âœ… App funciona completamente offline
- âœ… Datos consistentes entre sesiones
- âœ… Performance mejorado (no API calls en UI)
- âœ… UX superior con datos instantÃ¡neos
- âœ… Sync automÃ¡tico en background
- âœ… Conflict resolution robusto

Esta arquitectura asegura que la app sea **offline-first**, **performante** y **confiable**, siguiendo las mejores prÃ¡cticas modernas de Android development.

## ğŸ“‹ Estructura de Archivos a Crear

### Data Layer
```
data/
â”œâ”€â”€ datastore/
â”‚   â”œâ”€â”€ UserPreferencesRepository.kt
â”‚   â”œâ”€â”€ UserPreferences.kt
â”‚   â””â”€â”€ PreferencesKeys.kt
â”œâ”€â”€ database/
â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”œâ”€â”€ UserProfileEntity.kt
â”‚   â”‚   â”œâ”€â”€ P2POfferCacheEntity.kt
â”‚   â”‚   â”œâ”€â”€ MyOfferCacheEntity.kt
â”‚   â”‚   â””â”€â”€ FilterPreferencesEntity.kt
â”‚   â””â”€â”€ dao/
â”‚       â”œâ”€â”€ UserProfileDao.kt
â”‚       â”œâ”€â”€ P2POfferCacheDao.kt
â”‚       â”œâ”€â”€ MyOfferCacheDao.kt
â”‚       â””â”€â”€ FilterPreferencesDao.kt
â”œâ”€â”€ sync/
â”‚   â”œâ”€â”€ SyncManager.kt
â”‚   â”œâ”€â”€ SyncWorker.kt
â”‚   â””â”€â”€ ConflictResolver.kt
â””â”€â”€ network/
    â””â”€â”€ NetworkMonitor.kt
```

### Domain Layer
```
domain/
â”œâ”€â”€ model/
â”‚   â”œâ”€â”€ UserProfile.kt
â”‚   â”œâ”€â”€ P2POfferCache.kt
â”‚   â””â”€â”€ FilterPreferences.kt
â””â”€â”€ repository/
    â”œâ”€â”€ UserProfileRepository.kt (interface)
    â”œâ”€â”€ P2POfferCacheRepository.kt (interface)
    â””â”€â”€ SyncRepository.kt (interface)
```

### Dependency Injection
```
di/
â”œâ”€â”€ DataStoreModule.kt
â”œâ”€â”€ SyncModule.kt
â””â”€â”€ NetworkModule.kt (actualizar)
```

## ğŸ”§ Consideraciones TÃ©cnicas

### Performance
- Usar `@Transaction` para operaciones batch en Room
- Implementar paginaciÃ³n en queries grandes
- Cache inteligente con TTL (Time To Live)
- Lazy loading para datos pesados

### Security
- Encriptar tokens en DataStore
- Validar integridad de datos sincronizados
- Secure network calls con certificate pinning
- Backup/restore seguro de preferencias

### Testing
- Unit tests para cada Repository
- Integration tests para sync flows
- UI tests para scenarios offline/online
- Performance tests para queries grandes

### Monitoring
- Logging detallado de sync operations
- Metrics de performance de database
- Error tracking para sync failures
- Analytics de uso offline vs online

Esta implementaciÃ³n proporcionarÃ¡ una base sÃ³lida y escalable para el manejo de datos en la aplicaciÃ³n QvaPay Android.
